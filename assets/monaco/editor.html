<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlantUML Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1e1e1e;
        }
        #editor-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="editor-container"></div>

    <!-- QWebChannel for C++ communication -->
    <script src="qrc:/monaco/qwebchannel.js"></script>
    
    <!-- Monaco loader (AMD-style) -->
    <script src="qrc:/monaco/monaco-loader.js"></script>
    
    <!-- PlantUML language definition -->
    <script src="qrc:/monaco/plantuml-language.js"></script>

    <script>
        let editor = null;
        let bridge = null;
        let isUpdatingFromCpp = false;

        // Initialize QWebChannel connection
        function initWebChannel() {
            return new Promise((resolve, reject) => {
                if (typeof QWebChannel === 'undefined') {
                    reject(new Error('QWebChannel not available'));
                    return;
                }
                
                new QWebChannel(qt.webChannelTransport, function(channel) {
                    bridge = channel.objects.bridge;
                    if (bridge) {
                        // Connect to C++ signals
                        bridge.requestSetText.connect(function(text) {
                            if (editor) {
                                isUpdatingFromCpp = true;
                                editor.setValue(text);
                                isUpdatingFromCpp = false;
                            }
                        });
                        
                        bridge.requestSetLanguage.connect(function(language) {
                            if (editor) {
                                monaco.editor.setModelLanguage(editor.getModel(), language);
                            }
                        });
                        
                        bridge.requestSetReadOnly.connect(function(readOnly) {
                            if (editor) {
                                editor.updateOptions({ readOnly: readOnly });
                            }
                        });
                        
                        resolve(bridge);
                    } else {
                        reject(new Error('Bridge not found'));
                    }
                });
            });
        }

        // Initialize Monaco Editor
        function initMonaco() {
            return new Promise((resolve) => {
                // Register PlantUML language
                registerPlantUMLLanguage();
                
                // Create editor
                editor = monaco.editor.create(document.getElementById('editor-container'), {
                    value: '',
                    language: 'plantuml',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: false },
                    scrollBeyondLastLine: false,
                    fontSize: 13,
                    fontFamily: "'JetBrains Mono', 'Fira Code', 'Consolas', monospace",
                    lineNumbers: 'on',
                    renderLineHighlight: 'line',
                    wordWrap: 'on',
                    tabSize: 2,
                    insertSpaces: true,
                    folding: true,
                    bracketPairColorization: { enabled: true }
                });

                // Listen for content changes
                editor.onDidChangeModelContent(function() {
                    if (!isUpdatingFromCpp && bridge) {
                        bridge.notifyTextChanged(editor.getValue());
                    }
                });

                resolve(editor);
            });
        }

        // Main initialization
        async function init() {
            try {
                await initWebChannel();
                await initMonaco();
                
                // Notify C++ that editor is ready
                if (bridge) {
                    bridge.notifyEditorReady();
                }
            } catch (error) {
                console.error('Initialization error:', error);
            }
        }

        // Wait for Monaco to load, then initialize
        if (typeof monaco !== 'undefined') {
            init();
        } else {
            // Monaco loader will call monacoReady when loaded
            window.monacoReady = init;
        }
    </script>
</body>
</html>

